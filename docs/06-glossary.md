# Glossary

## V8 & JIT Compilation Terms

### Bailout
When V8 decides it cannot optimize a function due to specific language features (e.g., `eval`, complex `try-catch`, `with`). The function continues to run in the interpreter.

### Bytecode
Intermediate representation generated by V8's parser. Executed by the Ignition interpreter before optimization.

### Deoptimization (Deopt)
When V8 discards optimized machine code and falls back to interpreted bytecode because speculative assumptions were violated. Can be **eager** (immediate) or **lazy** (deferred).

### Elements Kind
V8's internal classification of array storage types. Examples:
- `PACKED_SMI_ELEMENTS`: Dense array of small integers
- `PACKED_DOUBLE_ELEMENTS`: Dense array of floats
- `PACKED_ELEMENTS`: Dense array of mixed types
- `HOLEY_*`: Sparse arrays with holes
- Transitions are **one-way** and **permanent**

### Feedback Vector
Data structure V8 uses to track type information observed during execution. Feeds into optimization decisions.

### Hidden Class (Shape/Map)
V8's internal representation of object structure. Objects with the same properties in the same order share a hidden class. Property access is optimized based on these classes.
- **Shape**: Common term in optimization literature
- **Map**: V8-specific internal term

### Ignition
V8's interpreter. Executes bytecode directly, collects type feedback for later optimization. Low startup overhead, decent throughput.

### Inline Cache (IC)
Caching mechanism for property access and function calls. Remembers the types seen at a particular call site.
- **States**: Uninitialized → Monomorphic → Polymorphic → Megamorphic
- **Transitions**: Generally one-way (can't go back from megamorphic)

### Inlining
Optimization where the compiler replaces a function call with the function's body. Eliminates call overhead and enables further optimizations.

### Maglev
V8's mid-tier optimizing compiler (introduced ~2022). Faster to compile than TurboFan, good enough optimization for most code.

### Megamorphic
IC state when a call site has seen 5+ different types. V8 gives up on type-specific optimization. **Silent killer** of performance.

### Monomorphic
IC state when a call site has seen exactly one type. Fastest case—V8 generates specialized code with no type checks.

### Polymorphic
IC state when a call site has seen 2-4 different types. V8 generates code with checks and branches. Still reasonably fast.

### Smi (Small Integer)
V8's tagged integer representation. 31-bit signed integers (on 64-bit systems) stored directly without heap allocation. Much faster than heap-allocated numbers.

### Speculation
V8's strategy of optimizing for observed types, then validating assumptions at runtime. If assumptions break, V8 deopts.

### TurboFan
V8's top-tier optimizing compiler. Generates highly optimized machine code based on type feedback. Slower to compile but produces the fastest code.

### Type Feedback
Runtime information V8 collects about the types and values flowing through code. Used to guide speculative optimization.

---

## Object & Array Internals

### Dictionary Mode
Fallback storage mode for objects when they become too dynamic (many properties added/deleted). Uses hash table instead of hidden class. Slower property access.

### Fast Properties
Objects stored with hidden classes and predictable offsets. Fast property access.

### Slow Properties
Objects in dictionary mode. Property access requires hash table lookup.

### Transition Tree
V8's internal structure tracking how hidden classes evolve as properties are added. Enables sharing of hidden classes across objects with the same shape evolution.

### Holes (in arrays)
Missing elements in sparse arrays (e.g., `[1, , 3]`). Trigger checks on every access. Degrade performance.

### Packed Array
Array with no holes. Can skip hole checks, enabling optimization.

### Holey Array
Array with holes. Must check for holes on access. Slower than packed.

---

## Optimization States

### Unoptimized
Code running in the Ignition interpreter. Collecting type feedback.

### Optimized
Code compiled by TurboFan (or Maglev) with speculative assumptions.

### Deoptimized
Optimized code was discarded due to assumption violations. Back to interpreter.

### Optimization Disabled
Function has been deoptimized too many times. V8 stops trying to optimize it.

---

## Performance Metrics

### Allocation Rate
Bytes allocated per second. High allocation rate → frequent GC → throughput/latency degradation.

### Event Loop Lag
Difference between expected and actual time for event loop iteration. Indicates blocking operations.

### GC Pause Time
Duration the garbage collector stops execution to reclaim memory. Affects latency.

### Throughput
Operations per second. Often measured as requests/second for servers.

### Latency
Time to complete a single operation. P50, P95, P99 are common percentiles.

---

## V8 Flags (Selection)

### `--trace-opt`
Logs when functions are optimized by TurboFan.

### `--trace-deopt`
Logs deoptimizations with reasons.

### `--trace-ic`
Logs inline cache state transitions.

### `--cpu-prof`
Generates CPU profile (Chrome DevTools format).

### `--trace-gc`
Logs garbage collection activity.

### `--allow-natives-syntax`
Enables V8 intrinsic functions (e.g., `%OptimizeFunctionOnNextCall()`). **Experimental only**, not for production.

### `--print-opt-code`
Prints generated machine code. Very verbose.

---

## Node.js Specific

### Back-Pressure
Flow control mechanism in streams. When a writable stream can't handle more data, it signals the readable stream to pause.

### Event Loop
Node.js's main execution loop. Processes callbacks from various phases (timers, I/O, immediate, close).

### Microtask Queue
Queue for `Promise` resolution callbacks. Processed between event loop phases.

### Worker Threads
Node.js threads for offloading CPU-intensive work. Separate V8 isolate per thread.

### Buffer
Node.js's binary data type. Wrapper around V8's `ArrayBuffer`. Optimized for I/O.

### TypedArray
JavaScript's typed arrays (`Uint8Array`, `Float64Array`, etc.). Efficient for numeric computation.

---

## Common Deopt Reasons

### "Insufficient type feedback"
Not enough data collected. Function called too few times before optimization attempt.

### "Wrong map"
Object shape changed. Hidden class mismatch.

### "Not a Smi"
Expected small integer, got float or heap number.

### "Not a heap number"
Type mismatch on numeric operation.

### "DivisionByZero"
Division by zero check failed.

### "Overflow"
Integer overflow detected.

### "Prototype chain changed"
Prototype was modified after optimization.

### "Out of bounds"
Array access outside bounds.

---

## Optimization Patterns

### Monomorphization
Ensuring call sites see only one type. Enables monomorphic ICs.

### Shape Stability
Keeping object shapes consistent. Prevents hidden class transitions.

### Elements Kind Stability
Keeping arrays homogeneous. Prevents elements kind transitions.

### Boundary Normalization
Converting heterogeneous inputs to consistent shapes at system boundaries. Keeps hot paths monomorphic.

### Try-Catch Isolation
Moving try-catch to wrapper functions. Allows hot path to be fully optimized.

---

## Anti-Patterns

### Megamorphic Call Site
Call site that sees many types. Always slow, no optimization possible.

### Shape Thrashing
Repeatedly changing object shapes. Causes frequent deopts.

### Allocation Churn
Creating many short-lived objects. Overwhelms GC.

### Event Loop Blocking
Long synchronous operations. Delays all I/O.

### Cargo Cult Optimization
Applying patterns without understanding or measurement. Wastes effort.

---

## Profiling Tools

### Chrome DevTools
Browser-based profiler. Can attach to Node.js via `--inspect`. Provides CPU profiles, heap snapshots, timeline.

### clinic.js
Node.js performance profiling suite. Includes:
- **Doctor**: Diagnoses event loop issues
- **Flame**: Flame graphs
- **Bubbleprof**: Async operations visualization

### 0x
Flame graph profiler specifically for Node.js.

### `--cpu-prof`
Node.js's built-in CPU profiler. Generates `.cpuprofile` files.

### `--prof` / `--prof-process`
V8's statistical profiler. More low-level than `--cpu-prof`.

---

## Terms to Avoid Confusing

### Deoptimization vs. Bailout
- **Deoptimization**: Discarding already-optimized code
- **Bailout**: Refusing to optimize in the first place

### Polymorphic vs. Megamorphic
- **Polymorphic**: 2-4 types (still optimizable)
- **Megamorphic**: 5+ types (no optimization)

### Smi vs. HeapNumber
- **Smi**: 31-bit integer, unboxed
- **HeapNumber**: All other numbers, heap-allocated

### Map vs. Hidden Class vs. Shape
- Same concept, different names:
  - **Map**: V8 internal term
  - **Hidden Class**: Academic/older V8 term
  - **Shape**: General optimization literature term

### Ignition vs. TurboFan
- **Ignition**: Interpreter (fast startup, decent speed)
- **TurboFan**: Optimizing compiler (slow startup, fast execution)

---

## Abbreviations

- **IC**: Inline Cache
- **GC**: Garbage Collector
- **JIT**: Just-In-Time (compiler)
- **IR**: Intermediate Representation
- **AST**: Abstract Syntax Tree
- **SSA**: Static Single Assignment (compiler IR form)
- **CSA**: CodeStubAssembler (V8 internal DSL)

---

## Further Reading

For deeper understanding:
- [V8 Blog](https://v8.dev/blog) - Official V8 team posts
- [Hidden Classes](https://v8.dev/docs/hidden-classes)
- [Elements Kinds](https://v8.dev/blog/elements-kinds)
- [Optimization Killers](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers) (older but still relevant)

---

Use this glossary as a reference while working through experiments and reading traces. Understanding these terms makes V8's behavior much less mysterious.
